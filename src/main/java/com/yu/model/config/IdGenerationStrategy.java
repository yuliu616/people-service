package com.yu.model.config;

/**
 * how to generate ID field for new record of a model class (table)
 */
public enum IdGenerationStrategy {

    /**
     * use a separate table with auto-number defined as its primary key (id).
     * create new record in it will return a new id which will be used as id
     * for the target class.
     */
    ID_TABLE,

    /**
     * use(generate) UUID as the id
     */
    UUID,

    /**
     * just generate a random number
     */
    RANDOM,

    /**
     * generate a random number, adding a predefined prefix
     */
    RANDOM_WITH_PREFIX,

    /**
     * generate a random number, adding a predefined suffix
     */
    RANDOM_WITH_SUFFIX,

    /**
     * keep a thread-safe counter in app server, use it as id
     * with predefined prefix added.
     */
    APP_SERVER_COUNTER_WITH_PREFIX,

    /**
     * keep a thread-safe counter in app server, use it as id
     * with predefined suffix added.
     */
    APP_SERVER_COUNTER_WITH_SUFFIX,

    /**
     * keep a thread-safe counter in app server, use it as id
     * with fixed prefix (random number generated once per server).
     */
    APP_SERVER_COUNTER_WITH_RANDOM_PREFIX,

    /**
     * a time-based number with random integer suffix.
     * (noted that jvm often return 000 for the last 3 digits of nano)
     * format:  YYYYMMDDHHmmssNNNNNNNNNRRRRRR (N for nano-second, R for random number)
     * example: 20220514034317888444000184933
     */
    TIME_BASED_SEQ_WITH_RANDOM_SUFFIX,

    /**
     * for each id generated by the ID table,
     * it will be multiplied by this factor first,
     * then, adding the Counter.
     * (that means, one row in ID table could produce many ID)
     * for example, ID table generated a '346' while the factor is '1000'.
     * then, the first ID produced will be 346001.
     * afterwards, the counter will keep glowing until 346999.
     * then, it will get a new ID from the ID table and reset the counter.
     */
    ID_TABLE_CROSSING_COUNTER,

}
